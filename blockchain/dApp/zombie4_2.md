# Payable 제어자

payable로 지정된 함수에선 이더리움을 받을 수 잇는 특수 함수이다. 

일반적인 API로는 보낼수 없지만 payable로는 보낼수 있다.

이 함수를 실행하기 위해선 컨트렉트에 일정금액을 지불해야 한다. 

```js
Contract OnlineStore {
    function buySomething() external payable {
        //함수 실행에 0.001이더가 보내졌는지 체크하는 함수 (> , <로도 이용가능)
        require(msg.value == 0.001 ether);
        transferthing(msg.sender); //이더를 이동..
    }
}
```

그럼 웹에서는 이 부분 호출하기 위해선

```js
// `OnlineStore`는 자네의 이더리움 상의 컨트랙트를 가리킨다고 가정해야 한다. 
OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})
```

> 주의 할점은 만약 함수가 payable 제어자가 없는 경우 이더를 보낸다고 하면 함수에서 트랙젝션을 거부를 할것이다.

# 출금시스템

이더를 보낸 후 출금을 하지 않는 경우 해당 컨트렉트의 이더리움 계좌에 저장되고 갇히게 된다. 

그래서 그걸 출금하는 시스템을 같이 개발해야 한다. 

```js
contract GetPaid is Ownable {
    //Owner 인지 체크
    function withdraw() external onlyOwner {
        //계좌에 있는 금액을 트렌스퍼한다. 
        owner.transfer(this.balance);
    }
}
```

그리고 초과 입금시 나머지를 돌려주는 로직을 짤려면 다음과 같다. 

```js
uint itemfee = 0.001 ether;
msg.sender.transfer(msg.value - itemFee); //입금하는 사람에게 출금하고 있다. 
```

만약 판매자가 있고 구매자가 물건을 구입시 이미 판매자가 storage 에 저장되었다는 가정하에

```
seller.transfer(msg.value) //지정된 판매자에게 금액을 출금하고 있다. 
```

# Keccak256을 통한 난수 생성

솔리디티에서 난수를 만들려면 `keccak256 `해시 함수를 사용하면 된다. 

```js
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNounce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNounce)) % 100;
```

now =&gt; 타임스탬프 값

실행시 0~99까지 난수를 만들 수 있다. 

# 참고사항

이더리움에서는 자네가 컨트랙트의 함수를 실행하면_**트랜잭션\(transaction\)**_으로서 네트워크의 노드 하나 혹은 여러 노드에 실행을 알리게 되네. 그 후 네트워크의 노드들은 여러 개의 트랜잭션을 모으고, "작업 증명"으로 알려진 계산이 매우 복잡한 수학적 문제를 먼저 풀기 위한 시도를 하게 되네. 그리고서 해당 트랜잭션 그룹을 그들의 작업 증명\(PoW\)과 함께_**블록**_으로 네트워크에 배포하게 되지.

한 노드가 어떤 PoW를 풀면, 다른 노드들은 그 PoW를 풀려는 시도를 멈추고 해당 노드가 보낸 트랜잭션 목록이 유효한 것인지 검증하네. 유효하다면 해당 블록을 받아들이고 다음 블록을 풀기 시작하지.

**이것이 우리의 난수 함수를 취약하게 만드네.**

우리가 동전 던지기 컨트랙트를 사용한다고 해보지 - 앞면이 나오면 돈이 두 배가 되고, 뒷면이 나오면 모두 다 잃는 것이네. 앞뒷면을 결정할 때 위에서 본 난수 함수를 사용한다고 가정해보세. \(`random >= 50`은 앞면,`random < 50`은 뒷면이네\).

내가 만약 노드를 실행하고 있다면, 나는**오직 나의 노드에만**트랜잭션을 알리고 이것을 공유하지 않을 수 있네. 그 후 내가 이기는지 확인하기 위해 동전 던지기 함수를 실행할 수 있지 - 그리고 만약 내가 진다면, 내가 풀고 있는 다음 블록에 해당 트랜잭션을 포함하지 않는 것을 선택하지. 난 이것을 내가 결국 동전 던지기에서 이기고 다음 블록을 풀 때까지 무한대로 반복할 수 있고, 이득을 볼 수 있네.

## 그럼 이더리움에서는 어떻게 난수를 안전하게 만들어낼 수 있을까? {#-}

블록체인의 전체 내용은 모든 참여자에게 공개되므로, 이건 풀기 어려운 문제이고 그 해답은 이 튜토리얼에를 벗어나네. 해결 방법들에 대해 궁금하다면[이 StackOverflow 글](https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract)을 읽어보게. 하나의 방법은 이더리움 블록체인 외부의 난수 함수에 접근할 수 있도록_**오라클**_을 사용하는 것이네.

물론, 네트워크 상의 수만 개의 이더리움 노드들이 다음 블록을 풀기 위해 경쟁하고 있으니, 내가 다음 블록을 풀 확률은 매우 낮을 것이네. 위에서 말한 부당한 방법을 쓰는 것은 많은 시간과 연산 자원을 필요로 할 것이야 - 하지만 보상이 충분히 크다면\(내가 천억 원을 걸 수 있다든지?\), 공격할 만한 가치가 있을 것이네.

그러니 이런 난수 생성은 이더리움 상에서 안전하지는 않지만, 실제로는 난수 함수가 즉시 큰 돈이 되지 않는 한, 자네 게임의 사용자들은 게임을 공격할 만한 충분한 자원을 들이지 않을 것이네.

이 튜토리얼에서는 시연 목적으로 간단한 게임을 만들고 있고 바로 돈이 되는 게 없기 때문에, 우린 구현하기 간단한 난수 생성기를 사용하는 것으로 타협할 것이네. 이게 완전히 안전하지는 않다는 걸 알긴 하지만 말이야.

향후 레슨에서는, 우린_**oracle**_\(이더리움 외부에서 데이터를 받아오는 안전한 방법 중 하나\)을 사용해서 블록체인 밖에서 안전한 난수를 만드는 방법을 다룰 수도 있네.

# Else 구문

```
if (zombieCoins[msg.sender] > 100000000) {
    
}else{
    
}
```



