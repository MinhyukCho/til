# 이진탐색 \(Binary Search\)

시나리오

> 1~1000개 숫자 의 배열에서 특정 숫자만 뽑아내고 싶을 경우 어떻게 해야 될까?

1. 리스트로 한개씩 넣어서 검색해서 운좋으면 빠른 시간안에 검색이 될 수 있으나 최악의 경우 1000번의 수행을 해야 한다. 
2. 이진탐색 알고리즘을 통해서 전체의 반을 검색하고 다시 반을 검색하는 방법을 사용할 수 있다. 

예를 들어 100의 중간 50부터 시작되는 함수로 시작된다.

1. 1~100 중에서 50부터 입력 -&gt; 너무 작다로 리턴됨
2. 51~100 중에서 75로 예측해서 입력 -&gt; 너무 크다로 리턴됨
3. 50~75 중에서 63으로 예측해서 입력 -&gt; 너무 크다로 리턴됨
4. 50~63 중에서 57로 예측해서 입력 -&gt; 정답

4번만에 답을 찾은 경우이다. 그럼 log~2~ 16 = 4 이라고 표시한다.

즉 로그는 거듭제곱의 반대말이다.

* 10^2^ = 100 -&gt; log~10~100 = 2
* 10^3 = 100 -&gt; log~10~1000 = 3
* 2^3 = 8 -&gt; log~2~8 = 3 \(결과값을 앞으로 보내면 된다.\)
* 2^4 = 16 -&gt; log~2~16 = 4
* 2^5 = 32 -&gt; log~2~32 = 5

위의 경우에는 정렬된 배열에 한해 해당되는 내용이었다. 하지만 실무에서는 보통 정렬이 안되어있는 경우가 많은 편이다.

그럼 어떻게 구현이 될까? 파이썬으로 시작해보자.

우선 먼저 배열 전체 길이를 설정하자.

```
low = 0
high = len(list) - 1
```

그리고 가운데를 딱 나누어서 원소를 확인해보자.

```
mid = (low + high) / 2 //반으로 나눈값 설정
guess = list(mid) //리스트의 반이 무엇인지 예측
```

추측한 값이 너무 작으면 low 값을 다음과 같이 변경 처리

```
if guess < item:
  low = mid + 1
```

또 큰 경우 high 값을 설정

```
if guess > item
  hight = mid -1
```

파이썬 전체 소스는 다음과 같다. 

```py
def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low <= high:
        mid = (low + high) // 2 #// 을 주의
        guess = list[mid]
        if guess == item:
            return mid
        if guess > item: #item보다 guess 가 큰경우 
            high = mid - 1
        else:
            low = mid + 1

    return None #아이템이 리스트에 없음


my_list = [1, 3, 5, 7, 9]
print(binary_search(my_list, 7))
```



